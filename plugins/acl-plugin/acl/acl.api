/* Hey Emacs use -*- mode: C -*- */
/*
 * Copyright (c) 2016 Cisco and/or its affiliates.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Define a simple binary API to control the feature */

define acl_plugin_get_version
{
  u32 client_index;
  u32 context;
};

define acl_plugin_get_version_reply
{
  u32 context;
  u32 major;
  u32 minor;
};

/*
 * Access List Rule entry
 */
typeonly manual_print manual_endian define acl_rule
{
  u8 is_permit;
  u8 is_ipv6;
  u8 src_ip_addr[16];
  u8 src_ip_prefix_len;
  u8 dst_ip_addr[16];
  u8 dst_ip_prefix_len;
/*
 * L4 protocol. IANA number. 1 = ICMP, 58 = ICMPv6, 6 = TCP, 17 = UDP.
 * 0 => ignore L4 and ignore the ports/tcpflags when matching.
 */
  u8 proto;
/*
 * If the L4 protocol is TCP or UDP, the below
 * hold ranges of ports, else if the L4 is ICMP/ICMPv6
 * they hold ranges of ICMP(v6) types/codes.
 *
 * Ranges are inclusive, i.e. to match "any" TCP/UDP port,
 * use first=0,last=65535. For ICMP(v6),
 * use first=0,last=255.
 */
  u16 srcport_or_icmptype_first;
  u16 srcport_or_icmptype_last;
  u16 dstport_or_icmpcode_first;
  u16 dstport_or_icmpcode_last;
/*
 * for proto = 6, this matches if the
 * TCP flags in the packet, ANDed with tcp_flags_mask,
 * is equal to tcp_flags_value.
 */
  u8 tcp_flags_mask;
  u8 tcp_flags_value;
};

typeonly manual_print manual_endian define macip_acl_rule
{
  u8 is_permit;
  u8 is_ipv6;
  u8 src_mac[6];
  u8 src_mac_mask[6];
  u8 src_ip_addr[16];
  u8 src_ip_prefix_len;
};

manual_print manual_endian define acl_add_replace
{
  u32 client_index;
  u32 context;
  u32 acl_index; /* ~0 to add, existing ACL# to replace */
  u8 tag[64]; /* What gets in here gets out in the corresponding tag field when dumping the ACLs. */
  u32 count;
  vl_api_acl_rule_t r[count];
};

define acl_add_replace_reply
{
  u32 context;
  u32 acl_index;
  i32 retval;
};

define acl_del
{
  u32 client_index;
  u32 context;
  u32 acl_index;
};

define acl_del_reply
{
  u32 context;
  i32 retval;
};

/* acl_interface_add_del(_reply) to be deprecated in lieu of acl_interface_set_acl_list */

define acl_interface_add_del
{
  u32 client_index;
  u32 context;
  u8 is_add;
  u8 is_input;
  u32 sw_if_index;
  u32 acl_index;
};

define acl_interface_add_del_reply
{
  u32 context;
  i32 retval;
};

manual_endian define acl_interface_set_acl_list
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;
  u8 count;
  u8 n_input; /* First n_input ACLs are set as a list of input ACLs, the rest are applied as output */
  u32 acls[count];
};

define acl_interface_set_acl_list_reply
{
  u32 context;
  i32 retval;
};

define acl_dump
{
  u32 client_index;
  u32 context;
  u32 acl_index; /* ~0 for all ACLs */
};

manual_print manual_endian define acl_details
{
  u32 context;
  u32 acl_index;
  u8 tag[64]; /* Same blob that was supplied to us when creating the ACL, one hopes. */
  u32 count;
  vl_api_acl_rule_t r[count];
};

define acl_interface_list_dump
{
  u32 client_index;
  u32 context;
  u32 sw_if_index; /* ~0 for all interfaces */
};

manual_endian define acl_interface_list_details
{
  u32 context;
  u32 sw_if_index;
  u8 count;
  u8 n_input;
  u32 acls[count];
};

manual_print manual_endian define macip_acl_add
{
  u32 client_index;
  u32 context;
  u8 tag[64];
  u32 count;
  vl_api_macip_acl_rule_t r[count];
};

define macip_acl_add_reply
{
  u32 context;
  u32 acl_index;
  i32 retval;
};

define macip_acl_del
{
  u32 client_index;
  u32 context;
  u32 acl_index;
};

define macip_acl_del_reply
{
  u32 context;
  i32 retval;
};

define macip_acl_interface_add_del
{
  u32 client_index;
  u32 context;
  u8 is_add;
  /* u8 is_input; macip ACLs are always input */
  u32 sw_if_index;
  u32 acl_index;
};

define macip_acl_interface_add_del_reply
{
  u32 context;
  i32 retval;
};

define macip_acl_dump
{
  u32 client_index;
  u32 context;
  u32 acl_index; /* ~0 for all ACLs */
};

manual_print manual_endian define macip_acl_details
{
  u32 context;
  u32 acl_index;
  u8 tag[64];
  u32 count;
  vl_api_macip_acl_rule_t r[count];
};

define macip_acl_interface_get
{
  u32 client_index;
  u32 context;
};

define macip_acl_interface_get_reply
{
  u32 context;
  u32 count;
  u32 acls[count];
};

